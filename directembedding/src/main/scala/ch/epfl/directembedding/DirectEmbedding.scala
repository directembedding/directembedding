package ch.epfl.directembedding

import ch.epfl.directembedding.transformers.ReifyAsEmbedding
import ch.epfl.yinyang.transformers.LanguageVirtualization
import ch.epfl.yinyang.EmbeddedControls

import scala.reflect.macros.blackbox.Context

final class MethodTree(x: Any)

class persist(id: MethodTree) extends scala.annotation.StaticAnnotation

protected[directembedding] object Macros {

  def inlineMethod(c: Context)(f: c.Tree, args: List[c.Tree], params: List[c.Symbol]): c.Tree = {
    import c.universe._
    import internal._, decorators._
    val q"def ${ _ }(..$params2): $tpe = $body" = f
    val paramsMap = (params zip args).map {
      case (param, arg) =>
        val temp = c.freshName(TermName(param.name.toString))
        val tempSym = c.internal.enclosingOwner.newTermSymbol(temp).setInfo(arg.tpe.widen)
        val valDef = c.internal.valDef(tempSym, c.internal.changeOwner(arg, c.internal.enclosingOwner, tempSym))

        (param.symbol, (tempSym, valDef))
    }.toMap

    // put a name of the val
    val inlinedBody = c.internal.typingTransform(body)((tree, api) => tree match {
      case i @ Ident(_) if paramsMap contains tree.symbol =>
        val sym = paramsMap(tree.symbol)._1
        api.typecheck(q"$sym")
      case _ =>
        api.default(tree)
    })

    q"""{
      ..${paramsMap.values.map(_._2)}
      ${c.untypecheck(inlinedBody)}
    }"""
  }

  def extractMethodTree(c: Context)(x: c.Expr[Any]): c.Expr[MethodTree] = {
    import c.universe._
    val argPos = x.tree.pos
    def isPersist(annot: Tree): Boolean = annot match {
      case Apply(Select(New(tn), termNames.CONSTRUCTOR), q"()" :: Nil) =>
        Set(
          "persist",
          "_root_.ch.epfl.directembedding.persist",
          "ch.epfl.directembedding.persist",
          "epfl.directembedding.persist",
          "directembedding.persist") contains tn.toString
      case _ =>
        false
    }

    def findAnnot(mods: Modifiers): Option[Tree] = mods.annotations.filter(isPersist) find {
      case Apply(_, args) if argPos == args.head.pos => true
      case _                                         => false
    }

    val defTreeList = (c.enclosingUnit.body: @unchecked).collect {
      case defdef @ DefDef(mods, p1, p2, p3, p4, p5) if findAnnot(mods).isDefined =>
        DefDef(
          Modifiers.apply(mods.flags, mods.privateWithin, mods.annotations.filterNot(isPersist)),
          p1, p2, p3, p4, p5)
    }

    if (defTreeList.isEmpty)
      c.abort(x.tree.pos,
        "@persist not found. Potential reason for this error is if @persist is generated by a meta-program.")

    val defTree = defTreeList.head
    c.Expr(q"new MethodTree({$defTree})")
  }

}
